SAT Solvers in Python
Resolution, Davisâ€“Putnam (DP), and DPLL Algorithms

This project provides a Python implementation of three classic satisfiability procedures used in propositional logic:

Resolution

Davisâ€“Putnam (DP)

Davisâ€“Putnamâ€“Logemannâ€“Loveland (DPLL)

The code includes detailed proof-style logging, closely matching the format used in theoretical lectures and on the whiteboard:

numbered clauses

rule applications (unit clause, pure literal, resolution)

derivation steps

branch exploration (for DPLL)

detection of contradictions or empty clauses

The goal is to combine working SAT solvers with transparent proof output to support both educational and research use cases.

Requirements

Python 3.9 or newer

No external dependencies are needed

To run the script, save it as:

sat_provers.py


and execute:

python3 sat_provers.py

1. Input Format

All SAT solvers operate on formulas expressed in CNF (Conjunctive Normal Form).

A CNF formula is represented as a list of clauses, where each clause is a frozenset of literals.

A literal is a string:

"P" for a positive literal

"~P" for a negated literal

A clause is a disjunction (OR) of literals

The CNF is a conjunction (AND) of clauses

Example CNF:

example_cnf = [
    frozenset({"~P1", "P2", "P3"}),
    frozenset({"P1", "P3", "P4"}),
    frozenset({"~P3", "~P6"}),
    frozenset({"P3", "~P4", "P1"}),
    frozenset({"~P2", "~P5"}),
    frozenset({"~P2", "P5"}),
    frozenset({"~P3", "P6"})
]


This corresponds to the formula:

(
Â¬
ð‘ƒ
1
âˆ¨
ð‘ƒ
2
âˆ¨
ð‘ƒ
3
)
âˆ§
(
ð‘ƒ
1
âˆ¨
ð‘ƒ
3
âˆ¨
ð‘ƒ
4
)
âˆ§
(
Â¬
ð‘ƒ
3
âˆ¨
Â¬
ð‘ƒ
6
)
âˆ§
â€¦
(Â¬P
1
	â€‹

âˆ¨P
2
	â€‹

âˆ¨P
3
	â€‹

)âˆ§(P
1
	â€‹

âˆ¨P
3
	â€‹

âˆ¨P
4
	â€‹

)âˆ§(Â¬P
3
	â€‹

âˆ¨Â¬P
6
	â€‹

)âˆ§â€¦
2. Using the Resolution Solver

The resolution solver attempts to derive the empty clause âˆ… using systematic resolution.

Call:

resolution_proof(example_cnf)


The program prints:

all initial clauses numbered

each new resolvent

the two parent clauses used for derivation

the literal resolved upon

termination when:

the empty clause is derived (UNSAT), or

no new clauses can be generated (resolution saturates)

Example output:

(1) {~P1, P2, P3}
(2) {P1, P3, P4}
...
(8) {P, ~Q} from (3) and (5) by resolving on P
Empty clause derived: UNSAT (by resolution).

3. Using the DP Solver (Davisâ€“Putnam)

DP iteratively applies:

Unit clause rule

Pure literal rule

Resolution between clauses (only when the first two rules cannot apply)

Call:

dp_proof(example_cnf)


The solver prints:

which rule is applied at each step

the updated clause set after each rule

the resolvent clauses added by rule III

termination when:

the empty clause arises (UNSAT), or

no more rules apply (SAT)

Example:

Step 1: Rule I (one-literal) with {~P2}
New K:
(1) {...}
Step 2: Rule II (pure literal) with P6
...
Empty clause âˆ… generated by resolution: UNSAT.

4. Using the DPLL Solver

DPLL combines:

Unit propagation

Pure literal elimination

Recursive splitting on a chosen literal

Call:

dpll_proof(example_cnf)


The solver prints:

every unit propagation step

every pure literal elimination

each branching decision (split rule)

backtracking messages

resulting model for satisfiable cases

termination when:

all branches lead to conflict (UNSAT), or

a full satisfying assignment is found (SAT)

Example:

Split on P1: try P1 = True
  Unit propagation: set P3 = False
  Found empty clause âˆ… => conflict, backtrack.
Backtrack. Now try P1 = False.
...
DPLL result: UNSAT.

5. Extending or Customizing the Program

The solvers are modular:

Add new heuristics for choosing literals in DPLL

Integrate heuristics for clause simplification

Replace string literals with integer-coded literals for performance

Add DIMACS parser support

The provided code aims for clarity and proof transparency, not raw performance.

6. Summary

This project implements three classical SAT algorithms:

Resolution

Based on deriving resolvents

Concludes UNSAT if âˆ… is derived

Matches exactly the logical proof system in textbooks

Davisâ€“Putnam (DP)

Systematically deletes clauses

Applies unit and pure literal rules

Adds resolvents only when needed

DPLL

Fundamentally a backtracking SAT solver

Employs propagation and splitting

Produces full satisfying assignments

All three solvers are instrumented with step-by-step proof logs, suitable for:

coursework

exam preparation

demonstrations of logical inference

teaching propositional logic
